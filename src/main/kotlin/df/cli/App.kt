/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */

package df.cli

import com.google.api.gax.longrunning.OperationFuture
import com.google.cloud.dialogflow.v2beta1.AgentsClient
import com.google.cloud.dialogflow.v2beta1.Environment
import com.google.cloud.dialogflow.v2beta1.EnvironmentsClient
import com.google.cloud.dialogflow.v2beta1.ExportAgentRequest
import com.google.cloud.dialogflow.v2beta1.ExportAgentResponse
import com.google.cloud.dialogflow.v2beta1.RestoreAgentRequest
import com.google.cloud.dialogflow.v2beta1.SearchAgentsRequest
import com.google.cloud.dialogflow.v2beta1.UpdateEnvironmentRequest
import com.google.cloud.dialogflow.v2beta1.Version
import com.google.cloud.dialogflow.v2beta1.VersionsClient
import com.google.protobuf.ByteString
import io.github.bucket4j.Bandwidth
import io.github.bucket4j.Bucket
import io.github.bucket4j.Refill
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.io.BufferedOutputStream
import java.io.File
import java.io.FileOutputStream
import java.time.Duration
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream
import kotlin.random.Random


class App(
    private val agentProjectBasePath: String = "projects/%s/agent",
    private val baseDownloadPath: String = "${System.getProperty("user.home")}/Downloads/tmp",
    private val liveEnvironmentPathTemplate: String = "$agentProjectBasePath/environments/Prod",
    private val updateDirectory: String = "$baseDownloadPath/updates",
) {
    private val client = AgentsClient.create()
    private val versionsClient = VersionsClient.create()
    private val environmentsClient = EnvironmentsClient.create()

    fun agentPathFrom(projectId: String) = liveEnvironmentPathTemplate.format(projectId)


    val refill = Refill.intervally(50, Duration.ofMinutes(1))
    val limit = Bandwidth.classic(50, refill)

    val bucket = Bucket.builder()
        .addLimit(limit)
        .build()

    suspend operator fun invoke(target: CommandOptions) = when(target) {
        CommandOptions.EXPORT -> exportAllAgents()
        CommandOptions.RESTORE-> zipAndRestoreAgents()
        CommandOptions.PUBLISH -> createEnvVersion()
    }

    private fun createVersion(projectId: String): Version {
        val livePath = agentProjectBasePath.format(projectId)
        val newVersion = versionsClient
            .listVersions(livePath)
            .iterateAll()
            .last()
            .run {
                Version.newBuilder().apply {
                    description = "Agent Restored From Zip Script"
                }.build()
            }
        return versionsClient.createVersion(livePath, newVersion)
    }

    fun updateLiveEnvironment(projectId: String, versionNumber: Int) {
        val env = Environment
            .newBuilder()
            .apply {
                name = agentPathFrom(projectId)
                agentVersion = "projects/$projectId/agent/versions/$versionNumber"
            }.build()

        UpdateEnvironmentRequest
            .newBuilder()
            .apply {
                updateMaskBuilder.addPaths("agent_version").build()
                this.environment = env
                allowLoadToDraftAndDiscardChanges = false

            }.build()
            .let { environmentsClient.updateEnvironment(it) }
    }

    private fun listFilesInUpdateDirectory() =
        File(updateDirectory)
            .listFiles(File::isDirectory)
            ?.toList()
            ?: emptyList()

    private fun cleanupUpdatesDirectory() = listFilesInUpdateDirectory()
        .forEach {
            it.deleteRecursively()
        }

    // TODO publish a version to Prod environment
    private suspend fun createEnvVersion() =
        listFilesInUpdateDirectory()
            .map {
                throttleOperation { createVersion(it.name) } to it

            }
            .map { (version, file) ->
                throttleOperation {
                    updateLiveEnvironment(version.name, version.versionNumber)
                }
                file
            }
            .forEach {
                println("Deleting file: ${it.name}")
                it.deleteRecursively()
            }

    private suspend fun doRandomDelay() = delay(Random.nextLong(500L, 1000L))

    private suspend fun <T> throttleOperation(block: suspend () -> T): T =
        bucket
            .tryConsumeAndReturnRemaining(1)
            .let { consumptionProbe ->
                if (consumptionProbe.remainingTokens == 0L) {
                    val sleepTime = Duration.ofNanos(consumptionProbe.nanosToWaitForReset).toMillis()
                    println("Hit rate limit: sleep for ${sleepTime}ms")
                    delay(sleepTime)
                }
                block()
            }

    suspend fun zipAndRestoreAgents() {
        val filesToRestore = listFilesInUpdateDirectory()
        val agentRestoreFutures = filesToRestore
            .zipAllDirectory()
            .map {
                it.absolutePath to it.readBytes()
            }
            .map { (zipFilePath, contentAsString) ->
                throttleOperation {
                    client.restoreAgentAsync(
                        RestoreAgentRequest
                            .newBuilder()
                            .apply {
                                parent = "projects/" + zipFilePath.split("/").last().replace(".zip", "")
                                agentContent = ByteString.copyFrom(contentAsString)
                            }.build()
                    )
                }
            }

        withContext(Dispatchers.IO) {
            while (!agentRestoreFutures.all { it.isDone }) {
                delay(500)
            }
        }
        agentRestoreFutures.forEachIndexed { idx, future ->
            val cleanupFile = filesToRestore[idx]
            val cleanupFilePath = cleanupFile.absolutePath
            future.get()
            println("Done uploading and restoring ${future.name}")
            println("Cleaning up file $cleanupFilePath.zip")
            File("$cleanupFilePath.zip").delete()
        }
    }

    private suspend fun List<File>.zipAllDirectory(): List<File> {
        val unzippedAgentDirs = this
            .map {
                val outputZipFile = File("${it.absolutePath}.zip")
                it to outputZipFile
            }

        return unzippedAgentDirs
            .map { (agentBaseFile, outputZipFile) ->
                println("about to zip $agentBaseFile to $outputZipFile")
                ZipOutputStream(BufferedOutputStream(FileOutputStream(outputZipFile))).use { zos: ZipOutputStream ->
                    agentBaseFile.walkTopDown().forEach { file ->
                        val zipFileName = file.absolutePath.removePrefix(File(updateDirectory).absolutePath).removePrefix("/")
                        val entry = ZipEntry("$zipFileName${(if (file.isDirectory) "/" else "")}")
                        zos.putNextEntry(entry)
                        if (file.isFile) {
                            file.inputStream().copyTo(zos)
                        }
                    }
                }
                outputZipFile
            }

    }

    suspend fun exportAllAgents() {
        val searchRequest = SearchAgentsRequest.newBuilder()
            .setPageSize(500)
            .setParent("projects/-")
            .build()

        val exportFutures = client.searchAgents(
            searchRequest
        )
            .iterateAll()
            .filter { it.parent.contains("prod") }
            .map {
                println("Kicking off download for: ${it.parent}")
                throttleOperation {
                    val exportRequest = ExportAgentRequest.newBuilder()
                        .apply {
                            parent = it.parent
                        }.build()
                    doRandomDelay()
                    it.parent to client.exportAgentAsync(exportRequest)
                }
            }

        withContext(Dispatchers.IO) {
            while (!exportFutures.all { it.second.isDone }) {
                delay(500)
            }
        }
        println("Moving on to download and unzip phase")
        exportFutures.forEach { (name, future) ->
            throttleOperation {
                val (baseFilePath, zipFilePath) = extractAndUnzip(name, future)
                doRandomDelay()
                println("Downloaded zip file: $zipFilePath and extracted to: $baseFilePath")
                File(zipFilePath).delete()
            }
        }
    }

    private fun extractAndUnzip(name: String, future: OperationFuture<ExportAgentResponse, *>): Pair<String, String> {
        val result = future.get().agentContent
        val baseFilePath = "$baseDownloadPath/downloads${name.replace("projects", "")}" // TODO make this config
        val zipFilePath = "$baseFilePath.zip"
        val outputFile = File(zipFilePath)
            .also {
                it.parentFile.mkdirs()
                it.createNewFile()
            }

        FileOutputStream(outputFile).use {
            result.writeTo(it)
        }
        outputFile.unzipFile()
        return baseFilePath to zipFilePath
    }

    private fun File.unzipFile() = ZipFile(this.absoluteFile).use { zip ->
        zip.entries().asSequence().forEach { entry ->
            zip.getInputStream(entry).use { input ->
                File(
                    "${this.absolutePath.replace(".zip", "")}/${entry.name}"
                ).also {
                    it.parentFile.mkdirs()
                    it.createNewFile()
                }
                    .outputStream().use { output ->
                        input.copyTo(output)
                    }
            }
        }
    }
}

